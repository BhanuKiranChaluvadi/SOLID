= Decorator Design Pattern
:toc:
:toc-placement!:

toc::[]

# Module Overview
Hello, my name is Dror Helper. And in this module, we will focus on one of my favorite design patterns, the decorator pattern. Just like with the previous modules, we will start with an overview of the decorator pattern, why we need it, and when we should use it in our code. We will then continue to cover the three different ways we can implement the decorator design pattern in C++. First, the dynamic inheritance base decorator that uses inheritance of a common base class, then the static template base decorator, and finally, we'll discuss how we can use functions as parameters and lambda functions to create decorators using the functional programming approach. We will finish this module with the benefits and tradeoffs of using the decorator pattern. So let's start by explaining what the decorator pattern is and in which scenarios we should use it.

# When to Use the Decorator Pattern
The decorator pattern is also known as a wrapper since it wraps existing code and forward calls to and from it. It is used to dynamically extend the class existing functionality, instead of using inheritance to add new functionality to existing objects. A decorator adds the new functionality by wrapping the decorated instance making the resulting class look exactly like the original class. Another aspect in which using the decorator is different from using inheritance is that a decorator acts upon a specific instance of an object and not necessarily all of the objects of the same type, so different instances of the same type could have different behaviors based on the decorators used. The main reason we would use the decorator pattern is when we want to add functionality to existing objects without rewriting or changing the original object. We can even add behaviors or data to objects which are not in our code base. And finally, we can mix and match different decorators creating new functionality combined from different types of decorators and even use several instances of the same decorator to create complex behavior. There are several different scenarios in which we would benefit from using the decorator pattern. The first one is when we cannot change the decorated class. There are several reasons I would not or could not change the original class. Maybe the original class belonged to old legacy code and I am not sure I can change it without breaking existing functionality, or perhaps I need to keep the existing behavior in other parts of my application that uses the same class, or maybe the decorated class is part of an existing library I'm using and it is outside of my code base so I can't change it. And so, regardless of my reasons, I can use a decorator whenever I need to add behavior to an instance I cannot or do not want to change. Another good reason to use the decorator pattern is when some of the features I need are optional. This way, I can keep them separate from a class and yet use them together when needed. A decorator is also useful when I want to add functionality to one or more of my classes and that functionality is not part of the business logic of those classes. Functionality, such as with _____, security checks, telemetry, and any other cross‑class functionality that should be used by several classes of different types. Those are known as cross‑cutting concerns and they complement object‑oriented programming by adding different behaviors on top of my classes without the need for code duplication or complex inheritance. And finally, I will use the corrector when my logic is built based on different combination of different functionalities. So instead of building complex inheritance trees and creating a lot of classes, I can use the correctors to add functionality in any order I need and add all the required functionality to a specific instance.

# Why We Need the Decorator Pattern
Consider the following example. I have the pure virtual class called OutputStream with a method called write that has a string parameter. I have two derived classes, FileStream that saves text to a file and MemoryStream that stores the text in the memory. Now I need to add different capabilities to my stream objects. I want to be able to encrypt the text and save the result, and I also want to compress the stream data to save disk space. With the aid of inheritance, I can create two classes that derive from FileStream, one for EncryptedFS and one for CompressedFS. But this solution is far from being perfect. First, I will need to implement similar logic by deriving MemoryStream, and I do not like to duplicate my code in such a way. And second, if I want to create a new type of stream that both encrypt and compress the result, I will need to create another duplicate implementation. What happens when I need to first compress the text and then encrypt it and not the other way around? Then I will need to create yet another class. And so with each new feature, I will create more and more classes to support every possible combination of the existing behaviors. This is a similar problem to the one we have solved in a previous module using the bridge pattern, but this time, I have more than two aspects to the system. And I need to support every combination possible of the features I have in my code, including running encryptions three times one after the other, so the bridge pattern is not applicable in this case. The solution is to create a base decorator class that inherits the same base class as FileStream and MemoryStream. We do that so we can impersonate the output stream using the decorator, and the decorator will look just like another stream in my system. Then we add a member to the decorator class of the type OutputStream. So basically, the decorator both inherit OutputStream and encapsulate an instance that also inherits OutputStream itself. Whenever the decorated method is called, write in this case, I will first call a method called encode to encode the text and then call the write method on the instance inside the decorator, forwarding the text to the next decorator in line. Finally, I can create two classes that inherit the decorator class and implement the encode method. I can add additional functions or even members to those two classes. Now when using the decorator, I can wrap the stream instance or even another decorator, and I can create complex behaviors. By using the decorator pattern, we have detached the new logic from the stream logic. I can even add general purpose decorators that have nothing to do with streams, for example, a logging decorator that just writes the text passed to it to a log. Another option I have is not to use the base decorator class at all and create decorater classes that inherit OutputStream directly. It depends on what makes most sense to you in your code. Okay, that's enough theory for now. Let's open our IDE and see an example on how to implement the decorator pattern.

# Implementing Dynamic Decorators


